# data_visualization

Задача 1. Выявление аномалий в стоимости автомобиля

Загрузите датасет из data/vehicles_dataset_upd.csv и выведите первые 5 записей.
 df = pd.read_csv('data/vehicles_dataset_upd.csv')
print(df.head())  
Постройте гистограмму распределения стоимости автомобиля, настройте размер фигуры — 8x5, цвет — indigo.
Не забудьте подписать название графика и оси.
 plt.figure(figsize=(8,5))
plt.hist(df.price, color="indigo", bins= 1000)
plt.xlabel("Цена")
plt.ylabel("Частота")
plt.title("Распределение цены")  
График гистограммы в таком виде не дает представления о реальном распределении, но из него можно сделать вывод о наличии выбросов.
Постройте «ящик с усами» для стоимости автобомиля, настройте размер фигуры — 5x15, а также примените форматирование для отображения значений стоимости.
Не забудьте подписать название графика и оси.
 plt.figure(figsize=(5, 15))
plt.boxplot(df.price, sym='+' )
plt.ylabel('Цена')
plt.title('Ящик с усами для цены')    
Из «ящика с усами» можно увидеть, что выбросы действительно существуют, но из-за их большого разброса основаная часть графика («ящик») почти незаметна.
Выведете описательные статистики стоимости автомобиля, чтобы изучить значения, обозначающие границы «ящика». С помощью apply(lambda x: f"{x:0.3f}") отобразите значения в удобном для восприятия виде.
 print(df.price.describe().apply(lambda x: f"{x:0.3f}"))
  
Выведете границы для нормальных значений стоимости автомобиля, используя интерквартильный размах. Посмотрите, входят ли минимальное и максимальное значения в интервал между полученными границами.
 boundaries = (df.price.quantile(0.25), df.price.quantile(0.75))
print('25% = ', boundaries[0], ', 75% = ', boundaries[1])  
Посчитайте и выведете количество выбросов в стоимости автомобиля. 
 is_outlier = (df.price < boundaries[0]) | (df.price > boundaries[1]) 
print("Количество выбросов:", is_outlier.sum())   
Выведете записи, в которых стоимость автомобиля попадает в выбросы, отсортированные по стоимости. Посмотрите на данные и подумайте, могут ли данные выбросы описывать особые значения категории цены или других признаков или действительно являются выбросами.
 print(df[(df.price < boundaries[0]) | (df.price > boundaries[1])].sort_values(['price']))  
Выведете последние 15 записей в отсортированном ранее датафрейме с выбросами, чтобы изучить признаки для наиболее дорогих автомобилей.
 print( df[(df.price < boundaries[0]) | (df.price > boundaries[1])].sort_values(['price'])[-15:])
  
Среди автомобилей с аномальной стоимостью действительно присуствуют автомобили, высокую стоимость которых можно объяснить, в первучю очередь, производителем и низким пробегом. Но будем опираться на стоимость основной массы автомобилей, поэтому удалите все аномальные значения и сохраните датафрейм без аномалий в переменную df_new, выведете первые 5 значений.
 df_new = df.drop(df[(df.price < boundaries[0]) | (df.price > boundaries[1])].index)
print(df_new.head())  Задача 2. Исследование зависимости стоимости автомобиля от года производства

Сформируйте и отобразите новый датафрейм, в котором будет содержаться статистика о годе производства автомобиля и среднем значении стоимости автомобиля за этот год (воспользуейтесь группировкой по годам). Не забудьте переименовать колонки согласно их содержанию.
 df_years = df_new.groupby('year').mean()[['price']]
print(df_years)  
Постройте диаграмму рассеяния для визуализации зависимости стоимости от года выпуска автомобиля. Не забудьте подписать название графика и оси.
 plt.figure(figsize=(10,10))
plt.scatter(df_years.index, df_years.price)
plt.ylabel("Price")
plt.xlabel("Year")
plt.title("Зависимость стоимости от года выпуска автомобиля")  
Из графика можно сделать вывод о возрастающем тренде: чем новее автомобиль, тем выше его цена. Исключение составляют наиболее старые и самые новые автомобили. Проверим, достаточно ли данных в выбивающихся из тренда значениях по годам. Для этого выведете количество автомобилей, произведенных в каждый год, воспользуейтесь группировкой по годам.
 print(df_new.groupby('year').count()[['lat']].rename(columns = {'lat':'count'}))
  
За последние два года мало накопленной информации — исключим их из исследования. С помощью фильтрации оставьте в датафрейме автомобили, произведенные не позднее 2021 года, выведете первые пять значений датафрейма.
 df_new = df_new[(df_new.year < 2021)]
print(df_new.head())  
На отфильтрованных данных повторите действия по формированию нового датафрейма, в котором будет содержаться статистика о годе производства автомобиля и среднем значении стоимости автомобиля за этот год. Не забудьте переименовать колонки согласно их содержанию.
 df_years_filt = df_new.groupby('year').mean()[['price']].rename(columns = {'price':'meanprice'})
print(df_years_filt)  
Постройте линейный график (plot) для визуализации зависимости стоимости от года выпуска автомобиля, настройте цвет линии —  blue, символ маркировки точек (marker) — ромб/алмаз — D, цвет точек (markerfacecolor) — orange.
Не забудьте подписать название графика и оси.
 plt.figure(figsize=(10,10))
plt.plot( df_years_filt.index,df_years_filt.meanprice, color='blue', marker = 'D', markerfacecolor = 'orange')
plt.ylabel("meanprice")
plt.xlabel("year")
plt.title("Зависимость стоимости от года автомобиля (линейный график)")
  
Посчитайте коэффициент корреляции Пирсона для стоимости автомобиля и года его производства. Ответьте на вопросы:
1. Можно ли сделать вывод о существовании линейной связи между стоимостью автомобиля и годом его производства? Почему?
Ваш ответ: __

2. Можно ли сделать вывод о сильной корреляции между стоимостью автомобиля и годом его производства? Почему?
Ваш ответ: __

3. Существующая связь является прямой или обратной? Почему?
Ваш ответ: __
 print(df_years_filt.reset_index().corr())
#№1 так как коэффициент корреляции не нулевой, линейная связь между стоимостью автомобиля и годом его производства существует
#№2 можно, так как коэффициент близок к 1
#№3 существуемая связь является прямой, так как коэффициент пололжительный
  
Для обновленных данных постройте гистограмму распределения стоимости автомобиля, настройте размер фигуры — 8x5, параметры количества интервалов — 20, цвет — indigo. Не забудьте подписать название графика и оси.
 plt.figure(figsize=(8,5))
plt.hist(df_new.price, bins = 20, color='indigo')
plt.xlabel("Price")
plt.ylabel("Lat")
plt.title("Гистограмма распределения стоимости автомобиля")  
Сохраните для дальнейшего использования датафрейм df_new в файл data/vehicles_dataset_upd2.csv, индексы не сохраняйте.
 df_new.to_csv('data/vehicles_dataset_upd2.csv', index = False)  Задача 3. Исследование зависимости ценовой категории автомобилиля от стоимости и года производства

На одном полотне постройте графики распределения стоимости автомобиля для каждой из ценовой категории автомобиля. Настройти общий размер фигуры — 12x8, параметры прозрачности — 0.7, цвета в зависимости от ценовой категории — зеленый, оранжевый и красный для низкой, средней и высокой ценовой категории соответственно. Не забудьте подписать название графика и оси, а также вывести легенду для ценовой категории. 
Подумайте, почему полученный график так выглядит? colors = {'low': 'green', 'medium': 'orange', 'high': 'red'}
fig, ax = plt.subplots(figsize=(12, 8))

for price_category in colors:
    color = colors[price_category]
    data = df_new[df_new['price_category'] == price_category]

    ax.hist(data['price'], color=color, alpha = 0.7, bins = 20)

ax.legend(colors, loc='upper right', title="Ценовая категория")

plt.ylabel('Количество')
plt.xlabel('Цена')
plt.title('Распределение стоимости автомобиля по ценовой категории')  
На одном полотне постройте диаграмму рассеяния для стоимости автомобиля и его года выпуска. Раскрасьте каждую точку (автомобиль) согласно ценовой категории автомобиля. Настройти общий размер фигуры — 12x8, цвета в зависимости от ценовой категории — зеленый, оранжевый и красный для низкой, средней и высокой ценовой категории соответственно. Не забудьте подписать название графика и оси, а также вывести легенду для ценовой категории, расположив ее в нижнем правом углу. 
 colors = {'low': 'green', 'medium': 'orange', 'high': 'red'}
fig, ax = plt.subplots(figsize=(12, 8))
for price_category in colors:
    color = colors[price_category]
    data = df_new[df_new['price_category'] == price_category]

    ax.scatter(data['price'], data['year'], c=color, )

ax.legend(colors, loc='lower right', title="Ценовая категория")
plt.title("Зависимость цены от года выпуска")
plt.xlabel('Price')
plt.ylabel('Год выпуска')  Задача 4. Визуализация категориальных переменных

Сформируйте и отобразите новый датафрейм, в котором будет содержаться статистика о производителе автомобиля и количестве произведенных им автомобилей (воспользуейтесь группировкой). Не забудьте переименовать колонки согласно их содержанию.
 df_proizvod = df_new.groupby('manufacturer').count()[['lat']].rename(columns = {'lat': 'count'})
print(df_proizvod)  
Постройте столбчатую диаграмму для производителей автомобиля, настройте размер фигуры — 20x10, ширину интервалов (width) — 0.9, цвета — чередующиеся springgreen и dodgerblue. Не забудьте подписать название графика и оси.
Для оси OX разверните подписи на 45 градусов, используя метод xticks и его параметр rotation.
 plt.figure(figsize=(20,10))
plt.bar(df_proizvod.index, df_proizvod['count'], width=0.9, color = ['springgreen', 'dodgerblue'])
plt.xlabel('Manufacturer')
plt.xticks(rotation = 45)
plt.ylabel('count')
plt.title('Распределение произваодителей')  
Сформируйте и отобразите новый датафрейм, в котором будет содержаться статистика о коробке передач автомобиля и количестве автомобилей с такой коробкой передач (воспользуейтесь группировкой). Не забудьте переименовать колонки согласно их содержанию.
 df_trans = df_new.groupby('transmission').count()[['lat']].rename(columns={'lat':'count'})
print(df_trans)  
Постройте круговую диаграмму для коробки передач автомобиля, настройте размер фигуры — 12x8, формат подписи о соотношении категорий, расстояние от метки о соотношении категорий до края сегмента. Не забудьте подписать название графика и оси, а также вывести легенду отдельно.
 plt.figure(figsize=(12,8))
plt.pie(df_trans['count'], labels=df_trans.reset_index()['transmission'], labeldistance=1.2, autopct = '%1.0f%%')
plt.legend()
plt.title('Распределение типа коробки передач')
plt.show()
